<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/public/api.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/api.js" />
              <option name="updatedContent" value="/**&#10; * API Module&#10; * Handles communication with the server&#10; */&#10;&#10;const API_CONFIG = {&#10;  URL: 'http://localhost:3000',&#10;  DATA_KEY: 'c4state',&#10;  API_KEY: 'c4game'&#10;}&#10;&#10;/**&#10; * Speichert den Spielzustand auf dem Server&#10; * @param {Object} state - Der zu speichernde Spielzustand&#10; * @returns {Promise&lt;Object&gt;} Server-Antwort&#10; */&#10;async function saveGameState(state) {&#10;  const url = `${API_CONFIG.URL}/api/data/${API_CONFIG.DATA_KEY}?api-key=${API_CONFIG.API_KEY}`&#10;  &#10;  const response = await fetch(url, {&#10;    method: 'PUT',&#10;    headers: {&#10;      'Content-Type': 'application/json'&#10;    },&#10;    body: JSON.stringify(state)&#10;  })&#10;&#10;  if (!response.ok) {&#10;    throw new Error(`HTTP error! status: ${response.status}`)&#10;  }&#10;&#10;  return response.json()&#10;}&#10;&#10;/**&#10; * Lädt den Spielzustand vom Server&#10; * @returns {Promise&lt;Object&gt;} Der geladene Spielzustand&#10; */&#10;async function loadGameState() {&#10;  const url = `${API_CONFIG.URL}/api/data/${API_CONFIG.DATA_KEY}?api-key=${API_CONFIG.API_KEY}`&#10;  &#10;  const response = await fetch(url)&#10;&#10;  if (!response.ok) {&#10;    throw new Error(`HTTP error! status: ${response.status}`)&#10;  }&#10;&#10;  return response.json()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/public/dom-helpers.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/dom-helpers.js" />
              <option name="updatedContent" value="/**&#10; * DOM Helper Functions&#10; * Utilities for creating and manipulating DOM elements&#10; */&#10;&#10;/**&#10; * Hilfsfunktion zum Erstellen von DOM-Elementen&#10; * @param {string} type - Tag-Name des Elements (z.B. &quot;div&quot;, &quot;span&quot;)&#10; * @param {Object} attrs - Objekt mit Attributen&#10; * @param {...(Node|string)} children - Kindelemente oder Text&#10; * @returns {HTMLElement} Das erstellte DOM-Element&#10; */&#10;function elt(type, attrs, ...children) {&#10;  const node = document.createElement(type)&#10;  &#10;  Object.keys(attrs).forEach(key =&gt; {&#10;    node.setAttribute(key, attrs[key])&#10;  })&#10;  &#10;  for (let child of children) {&#10;    if (typeof child !== &quot;string&quot;) {&#10;      node.appendChild(child)&#10;    } else {&#10;      node.appendChild(document.createTextNode(child))&#10;    }&#10;  }&#10;  &#10;  return node&#10;}&#10;&#10;/**&#10; * Zeigt eine Nachricht an&#10; * @param {string} text - Der anzuzeigende Text&#10; * @param {string} type - Der Nachrichtentyp ('success', 'error', 'info')&#10; * @param {boolean} persistent - Wenn true, wird die Nachricht nicht automatisch ausgeblendet&#10; */&#10;function showMessage(text, type = 'info', persistent = false) {&#10;  const messageDiv = document.getElementById('message')&#10;  messageDiv.textContent = text&#10;  messageDiv.className = `message ${type}`&#10;  messageDiv.style.display = 'block'&#10;&#10;  if (!persistent) {&#10;    setTimeout(() =&gt; {&#10;      messageDiv.style.display = 'none'&#10;    }, 3000)&#10;  }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/public/game-logic.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/game-logic.js" />
              <option name="updatedContent" value="/**&#10; * Connect4 Game Logic Module&#10; * Handles game rules and winner detection&#10; */&#10;&#10;/**&#10; * Überprüft, ob ein Spieler gewonnen hat&#10; * @param {string} player - Der zu prüfende Spieler ('r' oder 'b')&#10; * @param {Array&lt;Array&lt;string&gt;&gt;} board - Das Spielfeld als 2D-Array&#10; * @returns {boolean} true wenn der Spieler gewonnen hat, sonst false&#10; */&#10;function connect4Winner(player, board) {&#10;  const rows = board.length&#10;  const cols = board[0].length&#10;&#10;  /**&#10;   * Prüft ob 4 in einer Reihe ab Position (row, col) in Richtung (dRow, dCol)&#10;   */&#10;  function checkDirection(row, col, dRow, dCol) {&#10;    for (let i = 0; i &lt; 4; i++) {&#10;      const r = row + i * dRow&#10;      const c = col + i * dCol&#10;&#10;      if (r &lt; 0 || r &gt;= rows || c &lt; 0 || c &gt;= cols) {&#10;        return false&#10;      }&#10;&#10;      if (board[r][c] !== player) {&#10;        return false&#10;      }&#10;    }&#10;    return true&#10;  }&#10;&#10;  // Durchsuche alle Positionen und alle Richtungen&#10;  for (let row = 0; row &lt; rows; row++) {&#10;    for (let col = 0; col &lt; cols; col++) {&#10;      if (board[row][col] === player) {&#10;        // Horizontal, Vertikal, Diagonal rechts-unten, Diagonal links-unten&#10;        if (checkDirection(row, col, 0, 1) ||   // →&#10;            checkDirection(row, col, 1, 0) ||   // ↓&#10;            checkDirection(row, col, 1, 1) ||   // ↘&#10;            checkDirection(row, col, 1, -1)) {  // ↙&#10;          return true&#10;        }&#10;      }&#10;    }&#10;  }&#10;&#10;  return false&#10;}&#10;&#10;/**&#10; * Prüft ob das Board voll ist (Unentschieden)&#10; * @param {Array&lt;Array&lt;string&gt;&gt;} board - Das Spielfeld&#10; * @returns {boolean} true wenn alle Felder belegt sind&#10; */&#10;function isBoardFull(board) {&#10;  for (let row of board) {&#10;    for (let cell of row) {&#10;      if (cell === '') {&#10;        return false&#10;      }&#10;    }&#10;  }&#10;  return true&#10;}&#10;&#10;/**&#10; * Erstellt ein leeres Spielfeld&#10; * @param {number} rows - Anzahl Zeilen&#10; * @param {number} cols - Anzahl Spalten&#10; * @returns {Array&lt;Array&lt;string&gt;&gt;} Leeres Board&#10; */&#10;function createEmptyBoard(rows = 6, cols = 7) {&#10;  return Array(rows).fill('').map(() =&gt; Array(cols).fill(''))&#10;}&#10;&#10;/**&#10; * Findet die unterste freie Zeile in einer Spalte&#10; * @param {Array&lt;Array&lt;string&gt;&gt;} board - Das Spielfeld&#10; * @param {number} col - Die Spalte&#10; * @returns {number} Die Zeile oder -1 wenn Spalte voll ist&#10; */&#10;function findLowestFreeRow(board, col) {&#10;  for (let row = board.length - 1; row &gt;= 0; row--) {&#10;    if (board[row][col] === '') {&#10;      return row&#10;    }&#10;  }&#10;  return -1&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/public/game.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/public/game.js" />
              <option name="updatedContent" value="/**&#10; * Connect4 Game - Main Module&#10; * Coordinates game state, UI updates, and user interactions&#10; */&#10;&#10;// ========== Game State ==========&#10;const state = {&#10;  board: createEmptyBoard(),&#10;  currentPlayer: 'r',&#10;  gameOver: false,&#10;  winner: null&#10;}&#10;&#10;// ========== UI Rendering ==========&#10;&#10;/**&#10; * Rendert das Spielfeld basierend auf dem aktuellen State&#10; */&#10;function renderBoard() {&#10;  const boardElement = document.querySelector('.board')&#10;  boardElement.innerHTML = ''&#10;&#10;  for (let row = 0; row &lt; state.board.length; row++) {&#10;    for (let col = 0; col &lt; state.board[row].length; col++) {&#10;      const cellValue = state.board[row][col]&#10;      &#10;      const attrs = {&#10;        'class': 'field',&#10;        'data-row': String(row),&#10;        'data-col': String(col)&#10;      }&#10;&#10;      let field&#10;      if (cellValue === 'b') {&#10;        const bluePiece = elt('div', { class: 'blue piece' })&#10;        field = elt('div', attrs, bluePiece)&#10;      } else if (cellValue === 'r') {&#10;        const redPiece = elt('div', { class: 'red piece' })&#10;        field = elt('div', attrs, redPiece)&#10;      } else {&#10;        field = elt('div', attrs)&#10;      }&#10;&#10;      boardElement.appendChild(field)&#10;    }&#10;  }&#10;&#10;  updateStatusDisplay()&#10;}&#10;&#10;/**&#10; * Aktualisiert die Status-Anzeige (aktueller Spieler oder Gewinner)&#10; */&#10;function updateStatusDisplay() {&#10;  const statusDiv = document.querySelector('.status')&#10;&#10;  if (state.gameOver) {&#10;    if (state.winner) {&#10;      const winnerName = state.winner === 'r' ? 'Rot' : 'Blau'&#10;      const winnerColor = state.winner === 'r' ? '#f44336' : '#2196F3'&#10;      statusDiv.innerHTML = `Gewinner: &lt;span class=&quot;current-player&quot; id=&quot;currentPlayer&quot;&gt;&lt;/span&gt; ${winnerName}!`&#10;      const playerIndicator = document.getElementById('currentPlayer')&#10;      playerIndicator.style.backgroundColor = winnerColor&#10;    } else {&#10;      statusDiv.innerHTML = 'Unentschieden!'&#10;    }&#10;  } else {&#10;    const currentColor = state.currentPlayer === 'r' ? '#f44336' : '#2196F3'&#10;    statusDiv.innerHTML = 'Nächster Zug: &lt;span class=&quot;current-player&quot; id=&quot;currentPlayer&quot;&gt;&lt;/span&gt;'&#10;    const playerIndicator = document.getElementById('currentPlayer')&#10;    playerIndicator.style.backgroundColor = currentColor&#10;  }&#10;}&#10;&#10;// ========== Game Logic ==========&#10;&#10;/**&#10; * Handler für Klicks auf das Spielfeld&#10; */&#10;function handleBoardClick(event) {&#10;  // Blockiere Klicks wenn das Spiel vorbei ist&#10;  if (state.gameOver) {&#10;    if (state.winner) {&#10;      const winnerName = state.winner === 'r' ? 'Rot' : 'Blau'&#10;      showMessage(` ${winnerName} hat gewonnen!  Klicke auf &quot;Neues Spiel&quot; um neu zu starten.`, 'success', true)&#10;    } else {&#10;      showMessage('Unentschieden! Klicke auf &quot;Neues Spiel&quot; um neu zu starten.', 'info', true)&#10;    }&#10;    return&#10;  }&#10;&#10;  let clickedField = event.target&#10;&#10;  // Wenn auf die Figur geklickt wurde, gehe zum Eltern-Element&#10;  if (clickedField.classList.contains('piece')) {&#10;    clickedField = clickedField.parentElement&#10;  }&#10;&#10;  // Prüfe, ob es wirklich ein Feld ist&#10;  if (!clickedField.classList.contains('field')) {&#10;    return&#10;  }&#10;&#10;  const col = parseInt(clickedField.getAttribute('data-col'))&#10;  const targetRow = findLowestFreeRow(state.board, col)&#10;&#10;  // Wenn die Spalte voll ist, ignoriere den Klick&#10;  if (targetRow === -1) {&#10;    showMessage('Spalte ist voll!', 'error')&#10;    return&#10;  }&#10;&#10;  // Platziere den Spielstein&#10;  state.board[targetRow][col] = state.currentPlayer&#10;  renderBoard()&#10;&#10;  // Prüfe auf Gewinn&#10;  if (connect4Winner(state.currentPlayer, state.board)) {&#10;    state.gameOver = true&#10;    state.winner = state.currentPlayer&#10;    updateStatusDisplay()&#10;    const winner = state.currentPlayer === 'r' ? 'Rot' : 'Blau'&#10;    showMessage(` ${winner} hat gewonnen! `, 'success', true)&#10;    return&#10;  }&#10;&#10;  // Prüfe auf Unentschieden&#10;  if (isBoardFull(state.board)) {&#10;    state.gameOver = true&#10;    updateStatusDisplay()&#10;    showMessage('Unentschieden! Das Spielfeld ist voll.', 'info', true)&#10;    return&#10;  }&#10;&#10;  // Wechsle den Spieler&#10;  state.currentPlayer = state.currentPlayer === 'r' ? 'b' : 'r'&#10;  updateStatusDisplay()&#10;}&#10;&#10;/**&#10; * Startet ein neues Spiel&#10; */&#10;function newGame() {&#10;  state.board = createEmptyBoard()&#10;  state.currentPlayer = 'r'&#10;  state.gameOver = false&#10;  state.winner = null&#10;  renderBoard()&#10;  showMessage('Neues Spiel gestartet', 'success')&#10;}&#10;&#10;// ========== Server Communication ==========&#10;&#10;/**&#10; * Speichert das Spiel auf dem Server&#10; */&#10;async function handleSave() {&#10;  try {&#10;    await saveGameState(state)&#10;    showMessage('Spielstand erfolgreich gespeichert!', 'success')&#10;  } catch (error) {&#10;    console.error('Fehler beim Speichern:', error)&#10;    showMessage('Fehler beim Speichern: ' + error.message, 'error')&#10;  }&#10;}&#10;&#10;/**&#10; * Lädt das Spiel vom Server&#10; */&#10;async function handleLoad() {&#10;  try {&#10;    const loadedState = await loadGameState()&#10;&#10;    // Aktualisiere den lokalen State&#10;    state.board = loadedState.board&#10;    state.currentPlayer = loadedState.currentPlayer&#10;    state.gameOver = loadedState.gameOver || false&#10;    state.winner = loadedState.winner || null&#10;&#10;    renderBoard()&#10;&#10;    // Zeige entsprechende Meldung&#10;    if (state.gameOver &amp;&amp; state.winner) {&#10;      const winner = state.winner === 'r' ? 'Rot' : 'Blau'&#10;      showMessage(`Geladenes Spiel: ${winner} hat gewonnen!`, 'info', true)&#10;    } else if (state.gameOver) {&#10;      showMessage('Geladenes Spiel: Unentschieden!', 'info', true)&#10;    } else {&#10;      showMessage('Spielstand erfolgreich geladen!', 'success')&#10;    }&#10;  } catch (error) {&#10;    console.error('Fehler beim Laden:', error)&#10;    showMessage('Fehler beim Laden: ' + error.message, 'error')&#10;  }&#10;}&#10;&#10;// ========== Event Listeners ==========&#10;&#10;document.querySelector('.board').addEventListener('click', handleBoardClick)&#10;document.getElementById('newGameBtn').addEventListener('click', newGame)&#10;document.getElementById('saveBtn').addEventListener('click', handleSave)&#10;document.getElementById('loadBtn').addEventListener('click', handleLoad)&#10;&#10;// ========== Initialize ==========&#10;&#10;renderBoard()&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>